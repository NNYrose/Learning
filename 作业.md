### 1. 什么是Linux系统，Linux有哪些部分，Linux都用在了哪些地方？

1. Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。
2. Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。
3. 主要用途在服务器领域，安装在服务器上做服务器操作系统用，主要使用和维护者为技术人员； linux个人爱好者； 除了桌面和服务器操作系统以外，很多公共设施的机器也是liunx系统。

### 2. Linux和Windows有什么区别，Linux有哪些优势？

1. windows平台:数量和质量的优势，不过大部分为收费软件；由微软官方提供重要支持和服务 

   Linux平台：大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持
   安全性方面：
   Windows平台：三天两头打补丁安装系统安全更新，还是会中病毒木马什么的，各位用户自己感受。 
   Linux平台：要说linux没有安全问题，那当然是不可能的，不会中病毒什么的，也不可能，这一点仁者见仁智者见智，相对来说肯定比Windows平台要更加安全，使用linux你也不用装杀毒软件了。

2. 源码公开

   由于Linux系统的开发从一开始就与GNU项目紧密地结合起来，所以它的大多数组成部分都直接来自GNU项目。任何人、任何组织只要遵守GPL条 款，就可以自由使用Linux 源代码，为用户提供了最大限度的自由度。这一点也正投嵌入式系统所好，因为嵌入式系统应用千差万别，设计者往往需要针对具体的应用对源码进行修改和优化， 所以是否能获得源代码 对于嵌入式系统的开发是至关重要的。加之Linux的软件资源十分丰富，每种通用程序在Linux上几乎都可以找到，并且数量还在不断增加。这一切就使设 计者在其基础之上进行二次开发变得非常容易。另外，由于Linux源代码公开，也使用户不用担心有“后闸”等安全隐患。
   同时，源码开放给各教育机构提供极大的方便，从而也促进了Linux的学习、推广和应用。

3. 广泛的硬件支持

   Linux能支持x86、ARM、MIPS、ALPHA和PowerPC等多种体系结构的微处理器。目前已成功地移植到数十种硬件平台，几乎能运行在所有流行的处理器上。
   由于世界范围内有众多开发者在为Linux的扩充贡献力量，所以Linux有着异常丰富的驱动程序资源，支持各种主流硬件设各和最新的硬件技术，甚至可在没有存储管理单元MMU 的处理器上运行，这些都进一步促进了Linux在嵌入式系统中的应用。

4. 安全性及可靠性好

   内核高效稳定。Linux内核的高效和稳定已在各个领域内得到了大量事实的验证。
   Linux中大量网络管理、网络服务等方面的功能，可使用户很方便地建立高效稳定的防火墙、路由器、工作站、服务器等。为提高安全性，它还提供了大量的网络管理软件、网络分析软件和网络安全软件等。

5. 具有优秀的开发工具

   开发嵌入式系统的关键是需要有一套完善的开发和调试工具。传统的嵌入式开发调试工具是在线仿真器(In Circuit Emulator，ICE)，它通过取代目标板的微处理器，给目标程序提供一个完整的仿真环境，从而使开发者能非常清楚地了解到程序在目标板上的工作状 态，便于监视和调试程序。在线仿真器的价格非常高，而且只适合做非常底层的调试。如果使用的是嵌人式Linux，一旦软硬件能支持正常的串口功能，即使不 用在线仿真器，也可以很好地进行开发和调试工作，从而节省了一笔不小的开发费用。嵌入式Linux为开发者提供了一套完整的工具链(Tool Chain)，能够很方便地实现从操作系统到应用软件各个级别的调试。

6. 有很好的网络支持利文件系统支持

   Linux从诞生之日起就与Internet密不可分，支持各种标准的Internet网络协议，并且很容易移植到嵌入式系统当中。目前，Linux几乎支持所有主流的网络硬件、网络协议和文件系统，因此它是NFS的一个很好的平台。
   另一方面，由于Linux有很好的文件系统支持(例如，它支持Ext2、FAT32、romfs等文件系统)，是数据各份、同步和复制的良好平台，这些都为开发嵌入式系统应用打下了坚实的基础。

7. 与UNIX完全兼容

   目前，在Linux中所包含的工具和实用程序，可以完成UNIX的所有主要功能。
   但由于Linux不是为实时而设计的，因而这就成了Linux在实时系统中应用的最大遗憾。不过，目前有众多的自由软件爱好者正在为此进行不懈的努力，也取得了诸多成果

### 3. Linux的基本文件（夹）操作命令有哪些？
1. 创建文件

   ```shell
   $ touch filename
   ```

   这样创建是指在当前文件夹创建一个文件，也可以指定路径让他在指定目录下创建一个文件

2. 创建文件夹

   ```shell 
   $ mkdir name
   ```

   用法同上,创建文件夹是没有后缀名的

3. 删除文件以及文件夹

   ```shell
   $ rm filename
   ```

   删除使他会询问你确认删除，输入y按Enter确认删除，删除文件夹的命令为`rm -r name`他会询问你确认删除里面的文件什么的，每个文件什么的。如果觉得这样很烦，可以使用命令`rm -rf name`当然，这个也不仅限于输入文件名以及文件夹名，也是可以指定具体路径的。后面也是

4. 移动文件以及文件夹

   ```shell
   $ mv name /path/
   ```
   把某个文件移动到指定的路径,前面你要告诉他文件在哪，后面你要告诉他移动到哪去。

5. 复制文件夹

   ```shell
   $ cp name /path/
   ```
   
   用法同移动文件一样，顺带一提，文件夹也是这样操作的。

6. 查看具体文件（可以理解为以文本文件方式打开文件）

   ```shell
   $ cat name
   $ more name
   $ less name
   ```

   文件内容较少用cat文件内容较多用more或者less这2者都是只显示满屏的文件内容就不显示了，前者用空格键翻页，后可以pgup和pgdn翻页。

⑦查看当前目录下的内容

   ```shell
   $ ls
   ```

   这里也可以在后面指定具体的路径，显示指定文件夹下的内容，在后面跟参数-F
   ls -F这样就可以区分文件和文件夹了，文件夹后面有一个斜杠加以区分，如果感觉文件太多想以列表的形式显示。那就ls -l，如果想知道子文件夹下还有哪些东西就要ls -R，但是这样之后可能东西太多，不好看。当然这些后面跟的参数还可以组合起来使用。ls -FlR,注意区分大小写
### 4. 什么是开源软件，开源社区有哪些，开源软件有什么优势和劣势？
1. 开放源码软件(open-source)是一个新名词，它被定义为描述其源码可以被公众使用的软件，并且此软件的使用，修改和
    发也不受许可证的限制。开放源码软件通常是有copyright的，它的许可证可能包含这样一些限制: 蓄意的保护它的开放源码状态，著者身份的公告，或者开发的控制。"开放源码"正在被公众利益软件组织注册为认证标记，这也是创立正式的开放源码定义的一种手段。

2. zheng、JFinal、Nuts、t-io 、tiny、贝密游戏、iBase4J 等。
    中国社区新增开源项目2017排名：

| 排名 | 软件名 |
| :--: | :----: |
|  1   |  t-io  |
|  2   |  Guns  |
|  3   | iView  |
|  4   | UcKeFu |
|  5   | Neditor |

3. 优势
1、 更少的硬件和软件花费
因为Linux和其他开源软件解决方案很容易压缩和携带，所以当执行相同的任务时，它们会比在服务器如Solaris、Windows或工作站耗费更少的硬件资源。这样即使在使用陈旧、便宜的硬件条件下用户也可以得到预期的效果。此外，你还可以使用开源软件削减你的财务费用如版权费和维修费。你只需要为文档、媒体和技术支持付费。
 2、高质量
许多开源程序都有很高的质量，如容易设计，高效的编码过程。此外，由于有开发者和用户不断地对其进行功能的添加、修改，问题的解决，导致这些开源软件拥有越来越好的质量，更高的安全性和更少的bug。此外，这些开源软件的代码是可以使用的，这使得它们在用户中间非常流行。
3、 没有锁定供应商
使用开源软件意味着你没有被供应商锁定去使用特定的操作系统。因此，IT管理者使用他们来远离供应商锁定和支付高昂的版权费，同时避免使用可移植性较弱的软件。更重要的是，开源软件不依赖于原始开发者或开发公司。这样也就保证了在开发者或开发公司对特定产品的支持失去兴趣时，由广大的使用者组成的社区可以继续保持其活跃并不断完善它。
 4、综合管理和简单的许可证管理
开源软件使用的技术如常见的信息模型、基于web的企业管理，网站管理者可以使用这些技术进行综合管理并从中获益。此外，这些高端技术可以使使用者能够集成和管理服务器、应用、服务和工作站，提高管理效率。
劣势
1、没有免费的技术支持
开放源代码的最明显的劣势就是开发者会根据自己的意愿而不是消费者的需求开发产品，从而导致用户如果不知道怎样使用这些产品，不得不花费额外的时间或费用获得技术帮助。
2、安全性低
如果你的公司正在使用开源内容管理系统（CMS） 传输或保存敏感的客户数据，安全性是需要考虑的因素。然而，开源产品不是那么安全，许多企业将不会使用它们进行关键任务操作如金融和医疗记录。 
3、维护费用高
由于开源软件可以在互联网上免费得到，因此诞生了来自用户对bug修复和补丁的建议。这可能会导致大量的补丁，使得源代码更加复杂和导致结构问题。此外，任何问题都会导致高额的维修费用。

### 5.为什么要有版本控制，git都有哪些操作，和GitHub有什么关系
1. 作用一，备份用
   是的，代码需要备份的，这可能是版本控制工具的一个比较弱的功能，但真的很管用。程序员每做一步功能性的更新和迭代，都需要备份一次，这是一个很好的习惯，而在版本控制工具中你不需要再复制和粘贴，产生大量的代码冗余，你只需要提交一次到服务器中就可以了，注意，千万别写好几个功能后再一次提交，这并不是一个非常好的习惯，刚入行的程序员往往很容易范这个问题，一提交就好几个功能集中在一起提交。之前小编范过这个问题，提交的功能，有几个要留下有几个要弃用返回到之前的一个时间点，而这些功能错综复杂的交互数据，使这项工作施行起来要多复杂有多复杂。吃了这次教训后，才知道版本控制的重要性。
   按功能提交代码的好处很多，一来，可以知道哪次提交的具体功能，方便测试的同学单元功能测试。二来，是业务上的需求，可以方便找回之前的代码，因为可能需求改来改去，感觉还是以前写的功能好，需要回到以前某个时间点上，你只需要找一找那次提交的状态码，一条命令就可以回到那个时间点，而这个场景在实际开发中是经常遇到的。这时的版本控制工具就类似时间机器，可以让你的代码和网站很方便地返回去。

2. 作用二，协调开发用
   这个功能算是版本控制器的主要功能，开发一般很少有像ruby语言一样，一个人做一套系统，大部分的公司的开发团队少则十几个人，多则上百。当多个人共同开发一套系统的时候，你改一部分，我改一部分，肯定有代码冲突的地方，当多个人同时改了一个文件，这么多人，每个人改哪一块了？最终以谁的代码为准？如何处理这种场景下的代码冲突？这就是版本控制的协调开发作用，这在没有工具之前是非常麻烦，你需要打开至少两个窗口，一行一行的比较。
   十年前在第一家软件公司做开发的时候，公司用的是svn做版本控制，当时还没有git，当时市面上比较流行的是cvs和svn这两款，两个差不太多，随便用一款就行。我们向服务器提交的代码如果有冲突的时候，系统会以红色的代码块来做标记，提示我们需要更改，正常无冲突的代码是绿色的。
   而git是以多个左尖号来标注冲突的代码，凡是有改动的，均会以这种方式来注明。解决git冲突的办法就是把有尖号这一行删除，保留想要的代码块就可以了，具体长什么样子可以看下图。

   版本控制工具的选择
   CVS、SVN、Git是当下被广泛认可的版本控制工具，SVN是集中式的管理，git是分布式的。版本控制工具不像现在开发的框架一样，各有千秋，各有优势，现在基本上大部分新兴团队都会选择git做为代码管理的工具，而服务器部署来说，git也是非常方便的。
   git功能很多，可以完成不同的业务场景需求，但我们团队用的时候并没有那么复杂的用，对于前沿的开发人员来讲，可能最多用到的就是四条命令，git pull和git add 和 git commit -am 以及git push，这四条命令几乎占了操作的很大的一部分。而技术经理一般就负责审核、合并以及处理冲突，所以要用到更多的命令。
3. git忽略已经被纳入版本库的文件
   使用 git update-index –-skip-worktree [file] 可以实现修改本地文件不会被提交，但又可以拉取最新更改的需求。适用于一些不经常变动，但是必须本地化设置的文件
   另外还有 git update-index –-assume-unchanged [file] 该命令只是假设文件没有变动，使用reset时，会将文件修改回去
   NOTE: 该方法在使用add .命令添加所有文件到暂存区,commit提交到版本库,修改内容依然会被加入到版本库中
   重新跟踪 `git update-index --no-assume-unchanged`
   详细语法:

   ```
   git
   git update-index
         [--add] [--remove | --force-remove] [--replace]
         [--refresh] [-q] [--unmerged] [--ignore-missing]
         [(--cacheinfo <mode>,<object>,<file>)…]
         [--chmod=(+|-)x]
         [--[no-]assume-unchanged]
         [--[no-]skip-worktree]
         [--ignore-submodules]
         [--[no-]split-index]
         [--[no-|test-|force-]untracked-cache]
         [--really-refresh] [--unresolve] [--again | -g]
         [--info-only] [--index-info]
         [-z] [--stdin] [--index-version <n>]
         [--verbose]
         [--] [<file>…]
   ```

  ```
   Reference: git-update-index
   git commit without message
   Command: git commit -a --allow-empty-message -m ''
   or use a global configuration as following
   git config --global alias.nccommit 'commit -a --allow-empty-message -m ""'
   ```git

   git简介
   Git是分布式版本控制系统
   安装git后,配置用户名和email
   git config --global user.name "Your Name"
   git config --global user.email "email@example.com"
   不加--global参数只对当前仓库起作用,后面有更详细的介绍
   初始化git repository(版本库,仓库)
   git init
   添加文件到版本库
   git add readme.txt
   提交
   git commit -m "commit comment"
   查看版本库当前的状态
   git statuss
   查看工作区文件修改的内容
   git diff
   查看提交日志
   git log
   参数: --pretty=oneline 每个提交日志信息只显示一行
   显示最后一次提交信息
   git log -1
   版本回退
   git reset --hard 版本号 (或者HEAD)
   HEAD:代表当前版本,HEAD^代表上个版本,HEAD^^上上个版本......HEAD~100......
查看使用命令日志
git reflog
撤销修改
git checkout -- readme.txt
命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：
一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
总之，就是让这个文件回到最近一次git commit或git add时的状态。
git reset HEAD readme.txt
把暂存区的修改撤销掉（unstage），重新放回工作区.(工作区的文件内容无变化)
删除文件
在系统中删除过文件后,需要在版本库中删除,使用下面的命令(或者直接使用下面命令):
git rm readme.txt
git commit -m "remove readme.txt"
如果删错了,可以撤销修改,也就是回到版本库的状态: git checkout – readme.txt
生成SSH Key
ssh-keygen -t rsa -C "youremail@example.com"
生成后的key在 用户主目录/.ssh 下, id_rsa是私钥, id_rsq.pub是公钥
远程版本库
本地已有版本库,关联远程版本库:
git remote add origin 远程版本库URL
第一次推送
git push -u origin master
-u 参数: 把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以使用简化命令: git push origin master
本地没有版本库,克隆个新版本库:
git clone 远程版本库URL
默认的git:// 使用ssh协议, 也可以用 https:// 协议
使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令
分支管理
创建分支
git branch dev
切换分支
git checkout dev
创建并切换分支
git checkout -b dev
查看当前分支
git branch
git branch命令会列出所有分支，当前分支前面会标一个*号
合并分支
将dev分支合并到master分支,先切换到master分支上面,然后执行合并命令:
git merge dev
删除分支
git branch -d dev
用带参数的git log 查看分支的合并
git log --graph --pretty=oneline --abbrev-commit
git log --graph 命令可以看到分支合并图
合并分支时禁用Fast forward 模式
git merge --no-ff -m "merge with no-ff" dev
–no-ff 参数: 强制禁用Fast forward模式
通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息
如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息
BUG分支
储藏工作现场
git stash
可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作
切换到需要修复BUG的分支上(这步不能省略)
git checkout master
在需要修复BUG的分支上创建BUG分支并切换到BUG分支上
git checkout -b issue-101
修复完成后切换到需要修复BUG的分支上
git checkout master
合并分支
git merge --no-ff -m "merged bug fix 101" issue-101
删除BUG分支
git branch -d issue-101
切换到之前工作的分支上
git checkout dev
查看储藏工作现场的列表
git stash list
恢复工作现场的两种方式
git stash apply
恢复后，stash内容并不删除, 需要用git stash drop来删除
git stash pop
恢复的同时把stash内容也删了
多次stash
可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：
git stash apply stash@{0}
强行删除未合并的分支
git branch -D <branch name>
查看远程版本库信息
git remote
参数 -v 显示更详细的信息
推送本地master分支到远程版本库
git push origin master
推送本地dev分支到远程版本库
git push origin dev
创建远程origin的dev分支到本地
git checkout -b dev origin/dev
解决冲突
git pull
先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突(修改完文件后add commit)，再推送
指定本地dev分支与远程origin/dev分支的链接
git branch --set-upstream dev origin/dev
创建标签
切换到需要打标签的分支上,使用命令: git tag <name> 就可以打一个新标签
默认标签是打在最新提交的commit上的
例如: git tag v1.0
查看标签
git tag
查看所有标签
注意，标签不是按时间顺序列出，而是按字母排序的
使用commit id 创建标签
git tag v0.9 6224937
在任意commit点创建标签
查看标签信息
git show <tagname>
创建带有说明的标签
git tag -a v0.1 -m "version 0.1 released" 3628164
用-a指定标签名，-m指定说明文字
通过-s用私钥签名一个标签
git tag -s v0.2 -m "signed version 0.2 released" fec145a
签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错
删除标签
git tag -d v0.1
推送某个标签到远程
创建的标签都只存储在本地，不会自动推送到远程
如果要推送某个标签到远程，使用命令git push origin <tagname>
例如:
git push origin v1.0
一次性推送全部尚未推送到远程的本地标签
git push origin --tags
删除远程标签
先从本地删除
git tag -d v0.9
然后，从远程删除
git push origin :refs/tags/v0.9
配置Git显示颜色
git config --global color.ui true
ignore 忽略特殊文件
在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件
不需要从头写.gitignore文件
所有配置文件可以直接在线浏览：https://github.com/github/gitignore
如果你确实想添加该文件，可以用-f强制添加到Git
git add -f App.class
检查文件在.gitignore文件的哪条忽略规则中
git check-ignore -v App.class
配置别名
git config --global alias.<alias> <'git command'>
–global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用 配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用
每个仓库的Git配置文件都放在.git/config文件中 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中 删除别名: 别名就在配置文件中[alias]行后面，要删除别名，直接把对应的行删掉即可 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置
git config –global alias.unstage ‘reset HEAD’
配置别名: 把暂存区的修改撤销掉（unstage），重新放回工作区
使用:
git unstage test.java
git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset’ –abbrev-commit”
配置别名: 查看合并历史
搭建Git服务器
Linux: Ubuntu或Debian
第一步，安装git
sudo apt-get install git
第二步，创建一个git用户，用来运行git服务：
sudo adduser git
第三步，创建证书登录：
收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个
第四步，初始化Git仓库：
先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：
sudo git init --bare sample.git
Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：
sudo chown -R git:git sample.git
第五步，禁用shell登录：
出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：
git:x:1001:1001:,,,:/home/git:/bin/bash
改为：
git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出
第六步，克隆远程仓库：
现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：
$ git clone git@server:/srv/sample.git
Cloning into 'sample'...
warning: You appear to have cloned an empty repository.
剩下的推送就简单了
管理公钥
如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。
这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大
管理权限
有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具

（3）git是一种版本控制系统。跟svn、cvs是同级的概念。
github是一个网站，给用户提供git服务。这样你就不用自己部署git系统，直接用注册个账号，用他们提供的git服务就可以。
```
### 6.ARM架构处理器都有哪些，有什么特点，处理器的结构都有哪些，有哪些特点
  （1）
    ARM处理器特点：
　　1、体积小、低功耗、低成本、高性能；
　　2、支持Thumb（16位）/ARM（32位）双指令集，能很好的兼容8位/16位器件；
　　3、大量使用寄存器，指令执行速度更快；
　　4、大多数数据操作都在寄存器中完成；
　　5、寻址方式灵活简单，执行效率高；
　　6、指令长度固定。
  （2）ARM处理器结构
　　ARM和Thumb状态
　　RISC技术
　　流水线技术
　　超标量技术
　　ARM和Thumb状态
　　V4版以后有：
　　（1）32位ARM指令集
　　（2）16位Thumb指令集，功能是ARM指令集的功能子集。
　　ARM7TDMI核以后，T变种的ARM微处理器有两种工作状态：
　　（1）ARM状态
　　（2）Thumb状态。
　　当ARM微处理器执行32位的ARM指令集时，工作在ARM状态；
　　当ARM微处理器执行16位的Thumb指令集时，工作在Thumb状态
　　Thumb技术介绍
　　ARM7体系结构被广泛应用的时候，嵌入式控制器的市场仍然由8位、16位处理器占领。这些产品不能满足高端应用。这些应用需要32位RISC处理器的性能和更优于16位CISC处理器的代码密度。
　　为了解决代码密度的问题，ARM增加了T变种。
　　Thumb从32位ARM指令集中抽出来的36条指令格式，可重新编成16位的操作码。
　　在运行时，16位的Thumb指令又由处理器解压成32位指令。
　　Thumb核有2套独立的指令集，它使设计者得到ARM32位指令性能的同时，又能享有Thumb指令集产生的代码方面的优势，在性能和代码大小之间取得平衡。
　　和ARM指令集相比，Thumb指令集具有以下的局限：
　　完成相同的操作，Thumb指令通常需要更多的指令，因此在对系统运行时间要求苛刻的场合，ARM指令集更为合适。
　　Thumb指令集没有包含进行异常处理时需要的一些指令，因此在异常中断时，还是需要使用ARM指令，这种限制决定了Thumb指令需要与ARM指令配合使用。
　　ARM与Thumb状态转换
　　在程序的执行过程中，微处理器可以随时在两种工作状态之间切换，并且该转变不影响处理器的工作模式和相应寄存器中的内容。
　　进入Thumb状态：当操作数寄存器的状态位（位[0]）为1时，执行BX指令。
　　进入ARM状态：当操作数寄存器的状态位（位[0]）为0时，执行BX指令。
　　RISC技术
　　嵌入式微处理器可以分为两类：CISC和RISC；
　　CISC（Complex Instruction Set Computer）：复杂指令系统计算机；随着计算机技术的发展而不断引入新的复杂的指令集，计算机的体系结构会越来越复杂。
　　大约有20％的指令会被反复使用，占整个程序代码的80％，而余下的80％的指令却不经常使用，在程序设计中只占20％ 。
　　RISC（Reduced Instruction Set Computer）：精简指令系统计算机；－ 采用固定长度的指令格式
　　－ 使用单周期指令
　　－ 大量使用寄存器
　　－ 可用加载/存储指令批量传输数据
　　－ 在循环处理中使用地址的自动增减
　　RISC技术与CISC技术比较
　　 
　　RISC技术
　　ARM处理器采用加载/存储（Load/Store）体系结构是典型的RISC处理器，即只有Load/Store的存/取指令可以访问存储器，其余指令都不允许进行存储器操作。
　　RISC体系结构基本特点：
　　（1）大多数指令只需要执行简单和基本的功能，其执行过程在一个机器周期内完成。
　　（2）只保留加载/存储指令。操作数由加载/存储指令从存储器取出放寄存器内操作。
　　（3）芯片逻辑不采用或少采用微码技术，而采用硬布线逻辑。
　　（4）减少指令数和寻址方式。
　　（5）指令格式固定，指令译码简化。
　　（6）优化编译。
　　RISC技术
　　ARM体系结构还采用了一些特别的技术：
　　所有的指令都可根据前面的执行结果决定是否被执行，提高了指令的执行效率。
　　可用Load/Store指令批量传输数据，以提高数据的传输效率。
　　可在一条数据处理指令中同时完成逻辑处理和移位处理。
　　RISC和CISC各有优势，界限并不那么明显。
　　现代的CPU往往采用CISC的外围，内部加入了RISC的特性，如超常指令集CPU就是融合了RISC和CISC的优势，成为未来的CPU发展方向之一。
　　流水线技术
　　是一种将每条指令分解为多步，并让各步操作重叠，从而实现几条指令并行处理的技术；
　　程序中的指令仍是一条条顺序执行，但可以预先取若干条指令，并在当前指令尚未执行完时，提前启动后续指令的另一些操作步骤，从而可加快程序的运行速度；
　　 
　　 
　　开发和设计嵌入式系统的过程中，CPU的性能是一个非常重要的考虑因素。
　　流水线技术是在本质上影响程序执行速度的因素。
　　由于计算机中一条指令的各个执行阶段相对独立，因此，现代CPU大多设计成流水线型的机器，在这种类型机器中几个指令可以并行执行。采用流水线的重叠技术大大提高了CPU的运行效率。
　　当流水线内部的信息通畅流动时，CPU流水线能够工作得最好。
　　但实际应用中，指令各执行阶段的操作时间长短不同，有一些指令序列可能会打断流水线内的信息流，所以有时流水线操作不十分通畅，会暂时降低CPU的执行速度。
　　单周期指令的执行过程
　　 
　　ARM的3级流水线
　　ARM7架构采用了一个3段的流水线：
　　（1）取指：将指令从内存中取出来。
　　（2）译码：操作码和操作数被译码以决定执行什么功能。为下一周期准备数据路径需要的控制信号。这一级指令”占有“译码逻辑，而不是”占有”数据路径
　　（3）执行：执行已译码的指令。指令占有数据路径，寄存器堆栈被读取，操作数在桶行移位器中被移位。ALU产生运算结果并回写到目的寄存器中，ALU结果根据指令需求更改状态寄存器的条件位。
　　流水线模式下PC的更改过程
　　 
　　多周期ARM指令的3级流水线操作
　　数据路径涉及到所有执行周期、地址计算和数据传送。译码逻辑总是产生数据路径在下一个周期使用的控制信号，因此除译码周期以外，在STR地址计算周期也产生数据传送所需的控制信号。
　　取指的存储器访问和执行的数据路径占用都是不可同时共享的资源，对于多周期指令来说，如果指令复杂以至于不能在单个时钟周期内完成执行阶段，就会产生流水线阻塞。
　　ARM的流水线设计问题
　　1）缩短程序执行时间:
　　Tprog：执行一个程序所需时间；
　　Ninst：执行该程序的指令条数；
　　CPI：执行每条指令的平均时钟周期数；
　　Fclk：处理器的时钟频率。
　　措施：
　　提高时钟频率fclk（导致流水线的级数增加 ）。
　　减少每条指令的平均时钟周期数CPI（需要解决流水线的相关问题 ）
　　2）解决流水线相关:
　　结构相关：某些指令在流水线中重叠执行时，产生资源冲突 。
　　措施：1）采用分离式指令Cache和数据Cache。2）ALU中采用单独加法器来完成地址计算。
　　数据相关：当一条指令需要前面指令的执行结果，而这些指令均在流水线中重叠执行时，就可能引起流水线的数据相关。
　　数据相关有“写后读”、“写后写”和“读后写”等。
　　措施：1）旁路技术。2）流水线互锁技术。
　　控制相关：当流水线遇到分支指令和其他会改变PC值的指令时，就会发生控制相关。
　　措施：1）引入延时分支。2）尽早计算出分支转移成功时的PC值（即分支的目标地址）。
　　ARM的5级流水线
　　ARM9和StrongARM架构都采用了5级流水线.
　　增加了I-Cache和D-Cache，把存储器的取指与数据存取分开；
　　增加了数据写回的专门通路和寄存器；
　　把指令的执行过程分割为5部分:
　　取指：将指令从指令存储器中取出，放入指令流水线中。
　　指令译码：对指令进行译码，从寄存器堆中读取寄存器操作数。
　　执行：把一个操作数移位，产生ALU结果。如果指令是Load或Store，在ALU中计算存储器的地址。
　　数据缓存：如果需要，访问数据存储器；否则，ALU的结果只是简单地缓冲一个时钟周期，以便使所有指令具有同样地流水线流程。
　　写回 ：将指令产生地结果写回到寄存器堆。
　　流水线对比
　　超标量执行
　　通过重复设置多套指令执行部件，同时处理并完成多条指令，实现并行操作，来达到提高处理速度的目的。
　　所有ARM内核，包括流行的ARM7、ARM9和ARM11等，都是单周期指令机。
　　ARM公司下一代处理器将是每周期能处理多重指令的超标量机。
　　超标量处理机：一个时钟周期内同时执行多条指令的处理机。
　　超标量处理器中的多指令单元
　　超标量与流水线技术是兼容的，为了能够在一个时钟周期内同时发射多条指令，超标量处理机必须有两条或两条以上能够同时工作的指令流水线。但与此同时，也带来了多流水线的调度问题和操作部件的资源冲突问题。
　　超标量处理器在执行的过程中必须动态地检查指令相关性。
　　如果代码中有分支指令,必须将分支被执行和分支不被执行这两种情况分开考虑。
　　计算执行时间几乎是不可能的。
### 7.为什么在路由器中可以安装Linux，在路由器中使用的Linux和在桌面端使用的有什么区别

### 8. 为什么要有操作系统

1. 操作系统提供一系列底层接口和上层标准，“抹平”不同电脑之间的硬件差异，   这样只要操作系统相同，硬件能达到软件运行的最低标准，理论上这个软件就    能互通。
2. 操作系统可以为所有程序分配资源，一切程序要调用计算机资源都需要向操作    系统申请权限，这样就能最大程度利用计算机资源同时让各种程序不互相冲突。
3. 虽然操作系统本身也会占用一部分计算机资源，但是总体上它让计算机运行更为稳定，同时也减少了软件开发者的工作量，因为程序猿只需要考虑操作系统的标准接口，而不需要考虑硬件系统的底层差异

4. 虽然操作系统本身也会占用一部分计算机资源，但是总体上它让计算机运行更为稳定，同时也减少了软件开发者的工作量，因为程序猿只需要考虑操作系统的标准接口，而不需要考虑硬件系统的底层差异

### 9. 自己对计算机分层思想的理解
<ul>
<li>分层模型中，不同的层次意味着不同的抽象级别； <br>
<ul><li>抽象也是一种凝聚</li></ul></li>
<li>附庸的附庸不是附庸； <br>
<ul><li>每一层只需考虑与其相邻的上下两层，而无需考虑更高或者更低的层次；</li>
<li>不考虑，也即不关心（仅考虑自身），也即看不见，看不见更低和更高的层次；</li></ul></li>
<li>底层向高层提供服务；</li>
<li><strong>将物理层向上抽象为逻辑层</strong>，逻辑层向上提供<strong>公共接口</strong>，这样上层直接面对逻辑层，而无需直接跟复杂异构的物理层交互，这也是一种抽象和分层。 <br>
<ul><li>见下文的 LBA（磁盘逻辑分区）</li></ul></li>
</ul>

### 10. UART串口通信的层次结构是怎样的

    UART的设计采用模块化的设计思想，主要分为 3个模块：数据发送模块、数据接收模块及波特率发生器控制模块。发送模块实现数据由并行输入到串行输出，接收模块实现数据由串行输入到并行输出，波特率发生器模块控制产生UART时钟频率。

### 11. 为什么Qt可以跨平台使用而VS不能，C语言的编译步骤是怎样的，常用的编译器有哪些

1. Qt 是一个包含各种库的框架，通过对各种系统的接口实现进一步的抽象，屏蔽了系统的具体细节，使代码一次书写到处运行。VS是一个集成开发环境，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务。

2. C 语言的编译步骤包括预处理， 编译， 链接。

3. 常见的编译器有`gcc Clang icc`

### 12. C语言中主函数的返回值可以返回什么东西，主函数的参数又是如何确定的
1. 主函数会返回程序运行的状态， 0 代表成功， 1 代表失败， `stdio.h`中用下面的宏表示状态。
```
#defineEXIT_SUCCESS 0
#defineEXIT_FAILURE 1 
```
2. 这两个参数名字可以自定，但前者必须整形，后者是一个字符型指针数组，这个指针数组每个指针都指向一个字符串，前者就表示字符串的个数。

